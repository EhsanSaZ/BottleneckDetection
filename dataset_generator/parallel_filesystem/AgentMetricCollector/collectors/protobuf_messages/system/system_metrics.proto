syntax = "proto3";

message SystemMetrics {
  /*
        1 - 7 is generated using "cat /proc/{pid}/io;" command.
        To read more go to https://man7.org/linux/man-pages/man5/proc.5.html
        and search for "/proc/[pid]/io"
    */
  optional uint64 rchar = 1; //characters read; The number of bytes which this task has caused to be read from storage.
  optional uint64 wchar = 2; //characters written; The number of bytes which this task has caused, or shall cause to be written to disk.
  optional uint64 syscr = 3; //Attempt to count the number of read I/O operations—that is, system calls such as read(2) and pread(2).
  optional uint64 syscw = 4; //Attempt to count the number of write I/O operations—that is, system calls such as write(2) and pwrite(2).
  optional uint64 read_bytes_io = 5; //Attempt to count the number of bytes which this process really did cause to be fetched from the storage layer.  This is accurate for block-backed filesystems.
  optional uint64 write_bytes_io = 6; //Attempt to count the number of bytes which this process caused to be sent to the storage layer.
  optional uint64 cancelled_write_bytes = 7; //The big inaccuracy here is truncate.  If a process writes 1 MB to a file and then deletes the file, it will in fact perform no writeout.  But it will have been accounted as having caused 1 MB of write.  In other words: this field represents the number of bytes which this process caused to not happen, by truncating pagecache.  A task can cause "negative" I/O too.  If this task truncates some dirty pagecache, some I/O which another task has been accounted for (in its write_bytes) will not be happening.

  /*  8 - 14 are generated using "cat /proc/{pid}/stat;" command.
      To read more go to https://man7.org/linux/man-pages/man5/proc.5.html
      and search for "/proc/[pid]/stat"
  */
  optional int32 pid = 8; //The process id.
  optional int32 ppid = 9; //The PID of the parent of this process
  optional int32 pgrp = 10; //The process group ID of the process.
  optional int32 session = 11; //The session ID of the process.
  optional int32 tty_nr = 12; //The controlling terminal of the process.  (The minor device number is contained in the combination of bits 31 to 20 and 7 to 0; the major device number is in bits 15 to 8.)
  optional int32 tpgid = 13; //The ID of the foreground process group of the controlling terminal of the process.
  optional uint32 flags = 14; //The kernel flags word of the process.  For bit meanings, see the PF_* defines in the Linux kernel source file include/linux/sched.h.  Details depend on the kernel version. The format for this field was %lu before Linux 2.6.

  optional uint64 minflt = 15; //The number of minor faults the process has made which have not required loading a memory page from disk.
  optional uint64 cminflt = 16; //The number of minor faults that the process's waited-for children have made.
  optional uint64 majflt = 17; //The number of major faults the process has made which have required loading a memory page from disk.
  optional uint64 cmajflt = 18; //The number of major faults that the process's waited-for children have made.
  optional uint64 utime = 19; //Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).  This includes guest time, guest_time (time spent running a virtual CPU, see below), so that applications that are not aware of the guest time field do not lose that time from their calculations.
  optional uint64 stime = 20; //Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK))
  optional int64 cutime = 21; //Amount of time that this process's waited-for children have been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)). (See also times(2).)  This includes guest time, cguest_time (time spent running a virtual CPU, see below).
  optional int64 cstime = 22; //Amount of time that this process's waited-for children have been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

  optional int64 priority = 23; //(Explanation for Linux 2.6) For processes running a real-time scheduling policy (policy below; see sched_setscheduler(2)), this is the negated scheduling priority, minus one; that is, a number in the range -2 to -100, corresponding to real-time priorities 1 to 99.
  optional int64 nice = 24; //The nice value (see setpriority(2)), a value in the range 19 (low priority) to -20 (high priority).

  optional int64 num_threads = 25; //Number of threads in this process (since Linux 2.6).  Before kernel 2.6, this field was hard coded to 0 as a placeholder for an earlier removed field.
  optional int64 itrealvalue = 26; //The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.

  optional uint64 starttime = 27; //The time the process started after system boot.

  optional uint64 vsize = 28; //Virtual memory size in bytes.
  optional int64 rss = 29; //Resident Set Size: number of pages the process has in real memory.  This is just the pages which count toward text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.  This value is inaccurate; see /proc/[pid]/statm below.
  optional uint64 rsslim = 30; //Current soft limit in bytes on the rss of the process; see the description of RLIMIT_RSS in getrlimit(2).

  optional uint64 startcode = 31; //The address above which program text can run.
  optional uint64 endcode = 32; //The address below which program text can run.
  optional uint64 startstack = 33; //The address of the start (i.e., bottom) of the stack.
  optional uint64 kstkesp = 34; //The current value of ESP (stack pointer), as found in the kernel stack page for the process.
  optional uint64 kstkeip = 35; //The current EIP (instruction pointer).
  optional uint64 signal = 36; //[Obsolete] The bitmap of pending signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
  optional uint64 blocked = 37; //[Obsolete] The bitmap of blocked signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
  optional uint64 sigignore = 38; //[Obsolete] The bitmap of ignored signals, displayed as a decimal number.
  optional uint64 sigcatch = 39; //[Obsolete] The bitmap of caught signals, displayed as a decimal number.
  optional double wchan = 40; //This is the "channel" in which the process is waiting.  It is the address of a location in the kernel where the process is sleeping.

  optional uint64 nswap = 41; //Number of pages swapped (not maintained).
  optional uint64 cnswap = 42; //Cumulative nswap for child processes (not maintained).

  optional int32 exit_signal = 43; //Signal to be sent to parent when we die.
  optional int32 processor = 44; //CPU number last executed on.

  optional uint32 rt_priority = 45; //Real-time scheduling priority, a number in the range 1 to 99 for processes scheduled under a real- time policy, or 0, for non-real-time processes (see sched_setscheduler(2)).

  optional uint32 policy = 46; //Scheduling policy (see sched_setscheduler(2)). Decode using the SCHED_* constants in linux/sched.h.

  optional uint64 delayacct_blkio_ticks = 47; //Aggregated block I/O delays, measured in clock ticks (centiseconds).
  optional uint64 guest_time = 48; //Guest time of the process (time spent running a virtual CPU for a guest operating system), measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
  optional int64 cguest_time = 49; //Guest time of the process's children, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

  optional uint64 start_data = 50; //Address above which program initialized and uninitialized (BSS) data are placed.
  optional uint64 end_data = 51; //Address below which program initialized and uninitialized (BSS) data are placed.
  optional uint64 start_brk = 52; //Address above which program heap can be expanded with brk(2).
  optional uint64 arg_start = 53; //Address above which program command-line arguments (argv) are placed.
  optional uint64 arg_end = 54; //Address below program command-line arguments (argv) are placed.
  optional uint64 env_start = 55; //Address above which program environment is placed.
  optional uint64 env_end = 56; //Address below which program environment is placed.
  optional int32 exit_code = 57; //The thread's exit status in the form reported by waitpid(2).

  /*
      The fields 87 - 88 are generated using following command "ps -p [pid]  -o '%cpu,%mem';"
  */
  optional float cpu_usage_percentage = 58; //Total CPU usage percentage
  optional float mem_usage_percentage = 59; //Total Memory usage percentage
}