syntax = "proto3";

message NetworkMetrics{
  /*
        1 - 16 are the transfer metrics. It is generated by some computation using the
        values generated using "ss -t -i state ESTABLISHED dst [dst-ip];" command.
        The line which is parsed to generate the following fields is given below:

        Recv-Q       Send-Q                           Local Address:Port                             Peer Address:Port
        0            5814120                [::ffff:134.197.113.70]:36662                 [::ffff:134.197.113.71]:50505         users:(("java",pid=12466,fd=16))
        htcp wscale:13,13 rto:204 rtt:0.224/0.045 mss:1448 pmtu:1500 rcvmss:536
        advmss:1448 cwnd:456 ssthresh:424 bytes_acked:17599506586 segs_out:12192101
        segs_in:129549 data_segs_out:12192099 send 23581.7Mbps lastrcv:18044 pacing_rate 28298.1Mbps
        delivery_rate 7348.1Mbps busy:18024ms rwnd_limited:17584ms(97.6%) unacked:176 retrans:0/244
        reordering:174 rcv_space:14480 rcv_ssthresh:42242 notsent:5560320 minrtt:0.029
    */
  optional float avg_rtt_value = 1;
  optional float pacing_rate = 2; //p_avg_value
  optional float cwnd_rate = 3; //avg_cwnd_value
  optional float avg_retransmission_timeout_value = 4; //avg_rto_value
  optional float byte_ack = 5;
  optional float seg_out = 6;
  optional float retrans = 7; //retransmission ***
  optional float mss_value = 8; //avg_mss_rate
  optional float ssthresh_value = 9; //avg_ssthresh_value
  optional float segs_in = 10;
  optional float avg_send_value = 11;
  optional float unacked_value = 12; //unacked packets ***
  optional float rcv_space = 13; //avg_rcv_space
  optional float send_buffer_value = 14; //***
  optional float avg_dsack_dups_value = 15;
  optional float avg_reord_seen = 16;
}
message SystemMetrics {
  /*
        1 - 7 is generated using "cat /proc/{pid}/io;" command.
        To read more go to https://man7.org/linux/man-pages/man5/proc.5.html
        and search for "/proc/[pid]/io"
    */
  optional uint64 rchar = 1; //characters read; The number of bytes which this task has caused to be read from storage.
  optional uint64 wchar = 2; //characters written; The number of bytes which this task has caused, or shall cause to be written to disk.
  optional uint64 syscr = 3; //Attempt to count the number of read I/O operations—that is, system calls such as read(2) and pread(2).
  optional uint64 syscw = 4; //Attempt to count the number of write I/O operations—that is, system calls such as write(2) and pwrite(2).
  optional uint64 read_bytes_io = 5; //Attempt to count the number of bytes which this process really did cause to be fetched from the storage layer.  This is accurate for block-backed filesystems.
  optional uint64 write_bytes_io = 6; //Attempt to count the number of bytes which this process caused to be sent to the storage layer.
  optional uint64 cancelled_write_bytes = 7; //The big inaccuracy here is truncate.  If a process writes 1 MB to a file and then deletes the file, it will in fact perform no writeout.  But it will have been accounted as having caused 1 MB of write.  In other words: this field represents the number of bytes which this process caused to not happen, by truncating pagecache.  A task can cause "negative" I/O too.  If this task truncates some dirty pagecache, some I/O which another task has been accounted for (in its write_bytes) will not be happening.

  /*  8 - 14 are generated using "cat /proc/{pid}/stat;" command.
      To read more go to https://man7.org/linux/man-pages/man5/proc.5.html
      and search for "/proc/[pid]/stat"
  */
  optional int32 pid = 8; //The process id.
  optional int32 ppid = 9; //The PID of the parent of this process
  optional int32 pgrp = 10; //The process group ID of the process.
  optional int32 session = 11; //The session ID of the process.
  optional int32 tty_nr = 12; //The controlling terminal of the process.  (The minor device number is contained in the combination of bits 31 to 20 and 7 to 0; the major device number is in bits 15 to 8.)
  optional int32 tpgid = 13; //The ID of the foreground process group of the controlling terminal of the process.
  optional uint32 flags = 14; //The kernel flags word of the process.  For bit meanings, see the PF_* defines in the Linux kernel source file include/linux/sched.h.  Details depend on the kernel version. The format for this field was %lu before Linux 2.6.

  optional uint64 minflt = 15; //The number of minor faults the process has made which have not required loading a memory page from disk.
  optional uint64 cminflt = 16; //The number of minor faults that the process's waited-for children have made.
  optional uint64 majflt = 17; //The number of major faults the process has made which have required loading a memory page from disk.
  optional uint64 cmajflt = 18; //The number of major faults that the process's waited-for children have made.
  optional uint64 utime = 19; //Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).  This includes guest time, guest_time (time spent running a virtual CPU, see below), so that applications that are not aware of the guest time field do not lose that time from their calculations.
  optional uint64 stime = 20; //Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK))
  optional int64 cutime = 21; //Amount of time that this process's waited-for children have been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)). (See also times(2).)  This includes guest time, cguest_time (time spent running a virtual CPU, see below).
  optional int64 cstime = 22; //Amount of time that this process's waited-for children have been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

  optional int64 priority = 23; //(Explanation for Linux 2.6) For processes running a real-time scheduling policy (policy below; see sched_setscheduler(2)), this is the negated scheduling priority, minus one; that is, a number in the range -2 to -100, corresponding to real-time priorities 1 to 99.
  optional int64 nice = 24; //The nice value (see setpriority(2)), a value in the range 19 (low priority) to -20 (high priority).

  optional int64 num_threads = 25; //Number of threads in this process (since Linux 2.6).  Before kernel 2.6, this field was hard coded to 0 as a placeholder for an earlier removed field.
  optional int64 itrealvalue = 26; //The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.

  optional uint64 starttime = 27; //The time the process started after system boot.

  optional uint64 vsize = 28; //Virtual memory size in bytes.
  optional int64 rss = 29; //Resident Set Size: number of pages the process has in real memory.  This is just the pages which count toward text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.  This value is inaccurate; see /proc/[pid]/statm below.
  optional uint64 rsslim = 30; //Current soft limit in bytes on the rss of the process; see the description of RLIMIT_RSS in getrlimit(2).

  optional uint64 startcode = 31; //The address above which program text can run.
  optional uint64 endcode = 32; //The address below which program text can run.
  optional uint64 startstack = 33; //The address of the start (i.e., bottom) of the stack.
  optional uint64 kstkesp = 34; //The current value of ESP (stack pointer), as found in the kernel stack page for the process.
  optional uint64 kstkeip = 35; //The current EIP (instruction pointer).
  optional uint64 signal = 36; //[Obsolete] The bitmap of pending signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
  optional uint64 blocked = 37; //[Obsolete] The bitmap of blocked signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
  optional uint64 sigignore = 38; //[Obsolete] The bitmap of ignored signals, displayed as a decimal number.
  optional uint64 sigcatch = 39; //[Obsolete] The bitmap of caught signals, displayed as a decimal number.
  optional double wchan = 40; //This is the "channel" in which the process is waiting.  It is the address of a location in the kernel where the process is sleeping.

  optional uint64 nswap = 41; //Number of pages swapped (not maintained).
  optional uint64 cnswap = 42; //Cumulative nswap for child processes (not maintained).

  optional int32 exit_signal = 43; //Signal to be sent to parent when we die.
  optional int32 processor = 44; //CPU number last executed on.

  optional uint32 rt_priority = 45; //Real-time scheduling priority, a number in the range 1 to 99 for processes scheduled under a real- time policy, or 0, for non-real-time processes (see sched_setscheduler(2)).

  optional uint32 policy = 46; //Scheduling policy (see sched_setscheduler(2)). Decode using the SCHED_* constants in linux/sched.h.

  optional uint64 delayacct_blkio_ticks = 47; //Aggregated block I/O delays, measured in clock ticks (centiseconds).
  optional uint64 guest_time = 48; //Guest time of the process (time spent running a virtual CPU for a guest operating system), measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
  optional int64 cguest_time = 49; //Guest time of the process's children, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

  optional uint64 start_data = 50; //Address above which program initialized and uninitialized (BSS) data are placed.
  optional uint64 end_data = 51; //Address below which program initialized and uninitialized (BSS) data are placed.
  optional uint64 start_brk = 52; //Address above which program heap can be expanded with brk(2).
  optional uint64 arg_start = 53; //Address above which program command-line arguments (argv) are placed.
  optional uint64 arg_end = 54; //Address below program command-line arguments (argv) are placed.
  optional uint64 env_start = 55; //Address above which program environment is placed.
  optional uint64 env_end = 56; //Address below which program environment is placed.
  optional int32 exit_code = 57; //The thread's exit status in the form reported by waitpid(2).

  /*
      The fields 87 - 88 are generated using following command "ps -p [pid]  -o '%cpu,%mem';"
  */
  optional float cpu_usage_percentage = 58; //Total CPU usage percentage
  optional float mem_usage_percentage = 59; //Total Memory usage percentage
}
message BufferValueMetrics {
  /*
    The fields 1 - 3 are generated using following command "cat /proc/sys/net/ipv4/tcp_rmem".
    You can find further documentation in https://man7.org/linux/man-pages/man7/tcp.7.html
    and search tcp_rmem;
*/
  optional uint64 tcp_rcv_buffer_min = 1; //minimum size of the receive buffer used by each TCP socket.
  optional uint64 tcp_rcv_buffer_default = 2; //the default size of the receive buffer for a TCP socket.
  optional uint64 tcp_rcv_buffer_max = 3; //the maximum size of the receive buffer used by each TCP socket.

  /*
      The fields 4 - 6 are generated using following command "cat /proc/sys/net/ipv4/tcp_wmem".
      You can find further documentation in https://man7.org/linux/man-pages/man7/tcp.7.html
      and search tcp_wmem;
  */
  optional uint64 tcp_snd_buffer_min = 4; //minimum size of the send buffer used by each TCP socket.
  optional uint64 tcp_snd_buffer_default = 5; //the default size of the send buffer for a TCP socket.
  optional uint64 tcp_snd_buffer_max = 6; //the maximum size of the send buffer used by each TCP socket.
}
message ClientOstMetrics {
  /*
        The fields 1 - 15 are generated using following "lctl get_param osc.<ost-dir-name>.stats
        it contains statistics for the osc that is connected to the <ost-dir-name> ost
    */
  optional uint64 req_waittime = 1;
  optional uint64 req_active = 2;
  optional uint64 read_bytes = 3;
  optional uint64 write_bytes = 4;
  optional uint64 ost_setattr = 5;
  optional uint64 ost_read = 6;
  optional uint64 ost_write = 7;
  optional uint64 ost_get_info = 8;
  optional uint64 ost_connect = 9;
  optional uint64 ost_punch = 10;
  optional uint64 ost_statfs = 11;
  optional uint64 ost_sync = 12;
  optional uint64 ost_quotactl = 13;
  optional uint64 ldlm_cancel = 14;
  optional uint64 obd_ping = 15;
  /*
      The fields 16 - 17 generated using following "lctl get_param osc.<ost-dir-name>.rpc_stats
      it contains statistics for the osc that is connected to the <ost-dir-name> ost
  */
  optional uint64 pending_read_pages = 16;
  optional uint64 read_RPCs_in_flight = 17;
}
message ClientMdtMetrics {
  /*
        The fields 1 - 4 are generated using following "lctl get_param mdc.<mdt-dir-name>.import
        it contains statistics for the mdc that is connected to the <mdt-dir-name> mdt
    */
  optional uint64 avg_waittime_md = 1;
  optional uint64 inflight_md = 2;
  optional uint64 unregistering_md = 3;
  optional uint64 timeouts_md = 4;
  /*
      The fields 5 - 21 are generated using following "lctl get_param mdc.<mdt-dir-name>.import
      it contains statistics for the mdc that is connected to the <mdt-dir-name> mdt
  */
  optional uint64 req_waittime_md = 5;
  optional uint64 req_active_md = 6;
  optional uint64 mds_getattr_md = 7;
  optional uint64 mds_getattr_lock_md = 8;
  optional uint64 mds_close_md = 9;
  optional uint64 mds_readpage_md = 10;
  optional uint64 mds_connect_md = 11;
  optional uint64 mds_get_root_md = 12; // not appeared in stempede2
  optional uint64 mds_statfs_md = 13;
  optional uint64 mds_sync_md = 14;
  optional uint64 mds_quotactl_md = 15;
  optional uint64 mds_getxattr_md = 16;
  optional uint64 mds_hsm_state_set_md = 17;// not appeared in stempede2
  optional uint64 ldlm_cancel_md = 18;
  optional uint64 obd_ping_md = 19;
  optional uint64 seq_query_md = 20;
  optional uint64 fld_query_md = 21;// not appeared in stempede2
  /*
      The fields 22 - 36 are generated using following "lctl get_param mdc.<mdt-dir-name>.md_stats
      it contains statistics for the mdc that is connected to the <mdt-dir-name> mdt
  */
  optional uint64 close_md = 22;
  optional uint64 create_md = 23;
  optional uint64 enqueue_md = 24;
  optional uint64 getattr_md = 25;
  optional uint64 intent_lock_md = 26;
  optional uint64 link_md = 27;
  optional uint64 rename_md = 28;
  optional uint64 setattr_md = 29;
  optional uint64 fsync_md = 30;
  optional uint64 read_page_md = 31;
  optional uint64 unlink_md = 32;
  optional uint64 setxattr_md = 33;
  optional uint64 getxattr_md = 34;
  optional uint64 intent_getattr_async_md = 35;// not appeared in stempede2
  optional uint64 revalidate_lock_md = 36;
}
message ResourceUsageMetrics{
  // 1 - 2 are node cpu and memory cpu usage
  optional float system_cpu_percent = 1;
  optional float system_memory_percent = 2;
}
message LustreOstMetrics {
  // 1 - 2 are remote ost read and write bytes
  optional uint64 remote_ost_read_bytes = 1;
  optional uint64 remote_ost_write_bytes = 2;
}

message Metrics{
  optional double time_stamp = 1;
  optional NetworkMetrics network_metrics = 2;
  optional SystemMetrics system_metrics = 3;
  optional BufferValueMetrics buffer_value_metrics = 4;
  optional ClientOstMetrics client_ost_metrics = 5;
  optional ClientMdtMetrics client_mdt_metrics = 6;
  optional ResourceUsageMetrics resource_usage_metrics = 7;
  optional LustreOstMetrics  lustre_ost_metrics = 8;
  optional int32 label_value = 9;

}

message MonitoringLog {
  optional double time_stamp = 1;
  optional string transfer_ID = 2;
  optional Metrics metrics = 3;
  optional uint64 sequence_number = 4;
  optional int32 is_sender = 5;
}